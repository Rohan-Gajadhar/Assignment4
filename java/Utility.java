import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double distance = 0.0;

        distance += Math.pow((node1.getX() - node2.getX()), 2);
        distance += Math.pow((node1.getY() - node2.getY()), 2);

        double rawResult = Math.sqrt(distance);
        
        return rawResult;
        //int intResult = (int) Math.round(rawResult);
        //return (double) intResult;
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
        double totalCost = 0.0;

        Map<Integer, VRPNode> nodes = instance.getNodes();
        List<List<Integer>> routes = solution.getRoutes();

        //Depot to first node distance
        for(List<Integer> route : routes){
            VRPNode depot = instance.getDepot();
            VRPNode firstNode = nodes.get(route.get(0));

            totalCost += calculateEuclideanDistance(depot, firstNode);

            for(int i = 0; i < route.size() - 1; i++){
                VRPNode node1 = nodes.get(route.get(i));
                VRPNode node2 = nodes.get(route.get(i + 1));
                totalCost += calculateEuclideanDistance(node1, node2);
            }

            //Last node to depot distance
            VRPNode lastNode = nodes.get(route.get(route.size() - 1));
            totalCost += calculateEuclideanDistance(lastNode, depot);
        }

        return totalCost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        // TODO: Implement the nearest neighbour heuristic.

        //initialize
        Map<Integer, VRPNode> unvisited = instance.getNodes();
        unvisited.remove(instance.getDepot().getID());
        List<List<Integer>> routes = new ArrayList<List<Integer>>();

        while(unvisited.size() > 0){

            //create a new route starting from the depot
            List<Integer> route = new ArrayList<Integer>();
            routes.add(route);
            VRPNode currentNode = instance.getDepot();
            double remainingCapacity = instance.getCapacity();

            //iterate through nodes to find the nearest, skipping any which are infeasible
            while(remainingCapacity > 0 && unvisited.size() > 0){
                double nearestNodeDistance = Double.MAX_VALUE;
                VRPNode nearestFeasibleNode = null;
                for(int nodeId : unvisited.keySet()){
                    VRPNode node = unvisited.get(nodeId);

                    //skip any nodes which exceed the remaining capacity
                    if (node.getDemand() > remainingCapacity){
                        continue;
                    }

                    double distanceToNode = calculateEuclideanDistance(currentNode, node);

                    if (distanceToNode < nearestNodeDistance){
                        nearestNodeDistance = distanceToNode;
                        nearestFeasibleNode = node;
                    }
                }

                if (nearestFeasibleNode == null){
                    break;  //route is complete
                }

                //add the nearest feasible node to the route
                route.add(nearestFeasibleNode.getID());
                currentNode = nearestFeasibleNode;

                unvisited.remove(nearestFeasibleNode.getID());
                remainingCapacity -= nearestFeasibleNode.getDemand();
            }
        }

        VRPSolution sol = new VRPSolution(routes);
        
        return sol;
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {

        //initialize routes depot->node->depot for each node except the depot
        Map<Integer, VRPNode> allNodes = instance.getNodes();
        List<List<Integer>> routes = new ArrayList<List<Integer>>();
        for(int i = 2; i < allNodes.size(); i++){
            List<Integer> route = new ArrayList<Integer>();
            route.add(i);
            routes.add(route);
        }
        Boolean makingProgress = true;
        while(makingProgress){
            //initialize the best possible merge we have found thus far
            List<Integer> bestRoute1 = null;
            List<Integer> bestRoute2 = null;
            double bestSavings = Double.MIN_VALUE;

            for(int i = 0; i < routes.size() - 1; i++){
                List<Integer> route1 = routes.get(i);
                for(int j = 0; j < routes.size(); j++){
                    if(i == j){
                        continue;
                    }

                    List<Integer> route2 = routes.get(j);
                    VRPNode firstNodeInRoute1 = allNodes.get(route1.get(0));
                    VRPNode firstNodeInRoute2 = allNodes.get(route2.get(0));

                    VRPNode lastNodeInRoute1 = allNodes.get(route1.get(route1.size()-1));
                    VRPNode lastNodeInRoute2 = allNodes.get(route2.get(route2.size()-1));

                    double endRoute1_ToDepot = calculateEuclideanDistance(lastNodeInRoute1, instance.getDepot());
                    double depot_ToStartRoute2 = calculateEuclideanDistance(instance.getDepot(), firstNodeInRoute2);
                    double endRoute1_ToStartRoute2 = calculateEuclideanDistance(lastNodeInRoute1, firstNodeInRoute2);

                    //check route is feasible
                    double totalDemandForProposedRoute = 0;
                    for(int nodeId : route1){
                        totalDemandForProposedRoute += allNodes.get(nodeId).getDemand();
                    }
                    for(int nodeId : route2){
                        totalDemandForProposedRoute += allNodes.get(nodeId).getDemand();
                    }
                    if(totalDemandForProposedRoute > instance.getCapacity()){
                        continue;
                    }

                    //calculate savings
                    double savings = endRoute1_ToDepot + depot_ToStartRoute2 - endRoute1_ToStartRoute2;

                    //update best savings if necessary
                    if(savings > bestSavings){
                        bestSavings = savings;
                        bestRoute1 = route1;
                        bestRoute2 = route2;
                    }
                }
            }

            //if no savings were found, we are done
            if(bestRoute1 == null){
                makingProgress = false;
                break;
            }

            //merge the two routes with the best savings
            bestRoute1.addAll(bestRoute2);
            routes.remove(bestRoute2);
        }
        return new VRPSolution(routes);
    }
}
